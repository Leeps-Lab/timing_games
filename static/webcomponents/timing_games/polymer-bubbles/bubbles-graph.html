<!-- lots of this is stolen from https://www.html5canvastutorials.com/labs/html5-canvas-graphing-an-equation/ -->

<script src="colors.js"></script>

<dom-module id='bubbles-graph'>
<template>
    <style>
        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
    <canvas id='canvas'></canvas>
</template>
<script>
    Polymer({
        is: 'bubbles-graph',
        properties: {
            maxPayoff: {
                type: Number,
            },
            myDecision: {
                type: Number,
                observer: '_redrawGraph',
            },
            otherDecisions: {
                type: Array,
            },
            payoffFunction: {
                type: Object,
            },
            updateRate: {
                type: Number,
            },
            displayLower: {
                type: Number,
            },
            displayUpper: {
                type: Number,
            },
            constantA: {
                type: Number,
            },
            constantD: {
                type: Number,
            },
            constantH: {
                type: Number,
            },
            numPlayers: {
                type: Number,
            },
            pixelValues: {
                type: Array,
                value: [],
            },
            othersPixelValues: {
                type: Array,
                value: [],
            },
            updateLandscape: {
                type: Boolean,
                value: false,
            },
            enablePayoffLandscape: {
                type: Boolean,
                value: false,
            },
            // configuration property for how others' bubbles are displayed
            // 3 options
            //     'none': no bubbles are shown for other players
            //     'strategy': just shows everyone's strategy, without showing their payoff
            //     'payoff': shows everyone else's payoffs as well as their strategy
            othersBubbles: {
                type: String,
            }
        },
        observers: [
            '_redrawGraph(otherDecisions)',
        ],

        ready() {

            this.constantD = Math.exp(-0.6931/this.get("constantH"));

            setTimeout(() => {
                this.canvas = this.$.canvas;
                this.width = this.canvas.clientWidth;
                this.height = this.canvas.clientHeight;
                this.canvas.width = this.width;
                this.canvas.height = this.height;

                this.xMin = 0 - ((2 * this.get('constantA') + 1) * 0.06);
                this.xMax = (2 * this.get('constantA') + 1) * 1.03;
                this.xRange = this.xMax - this.xMin;
                this.yMin = 0 - this.maxPayoff * 0.1;
                this.yMax = this.maxPayoff * 1.05;
                this.yRange = this.yMax - this.yMin;

                this.xScale = this.width / this.xRange;
                this.yScale = this.height / this.yRange;

                this.ctx = this.canvas.getContext('2d');

                this._drawXAxis();
                this._drawYAxis();
            });

            for(let i = 0; i < 598; i++) {
                let val;
                if(i < this.get('displayLower')/(this.get('constantA') * 2 + 1) * 598) {
                    val = 0;
                }
                else if(i > this.get('displayUpper')/(this.get('constantA') * 2 + 1) * 598) {
                    val = this.maxPayoff;
                }
                else {
                    val = (i/this.maxPayoff) * (this.get("constantA") * 2 + 1);
                }
                this.push('pixelValues', val);
            }

            /*
            for(let i = 0; i < this.get('numPlayers') - 1; i++) {
                let arr = [];
                for(let j = 0; j < 598; j++) {
                    const val = (j/this.maxPayoff) * (this.get("constantA") * 2 + 1);
                    arr.push(val);
                }
                this.push('othersPixelValues', arr);
            }*/

        },
        roundStart() {
            setTimeout(this._redrawGraph.bind(this));
            let startTime = Date.now();
            function tick() {
                this.updateLandscape = true;
                this._redrawGraph();
                const timeDiff = Date.now() - startTime;
                setTimeout(tick.bind(this), this.get('updateRate') - timeDiff % this.get('updateRate'));
            }
            tick.call(this);
            //setInterval(this._redrawGraph.bind(this), this.get('updateRate'));
        },
        _redrawGraph() {
            if (!this.ctx) {
                return;
            }

            //console.log(this.get("otherDecisions"));

            this.ctx.clearRect(0, 0, this.width, this.height);
            this._drawXAxis();
            this._drawYAxis();
            if (this.enablePayoffLandscape) {
                this._drawPayoffLandscape();
            }
            if (this.othersBubbles !== 'none') {
                this._drawOthersBubbles();
            }
            this._drawMyDecision();
            this.updateLandscape = false;
        },
        _transformContext() {
            // changes bounds and scale of context so that x goes from xmin to xmax
            // and y goes from ymin to ymax
            this.ctx.scale(this.xScale, -this.yScale);
            this.ctx.translate(-this.xMin, -this.yMax)
        },
        _drawPayoffLandscape() {
            const ctx = this.ctx;

            const payoffFunction = this.get('payoffFunction');
            const otherDecisions = this.get('otherDecisions');

            ctx.save();
            ctx.save();
            this._transformContext();
            ctx.beginPath();

            const numSamples = this.width;
            const interval = this.xMax / numSamples;
            ctx.moveTo(0, payoffFunction(0, otherDecisions));
            var count = 0;
            for(let x = 0 + interval; x < this.xMax; x += interval) {
                let y;
                if(this.get('updateLandscape')) {
                    y = (1 - this.get("constantD")) * payoffFunction(x, otherDecisions) + this.get("constantD") * this.get("pixelValues")[count];
                }
                else {
                    y = this.get('pixelValues')[count];
                }
                ctx.lineTo(x, y);
                //console.log(this.get("pixelValues"));
                this.pixelValues[count] = y;
                count++;
                //console.log(count);
            }
            //console.log(this.get('pixelValues'));

            ctx.restore();
            ctx.lineJoin = 'round';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
        },
        _drawOthersBubbles() {
            const ctx = this.ctx;

            const payoffFunction = this.get('payoffFunction');
            const otherDecisions = this.get('otherDecisions');

            ctx.save();

            const radius = 8;
            for(let i = 0; i < otherDecisions.length; i++) {
                let payoff = 0;
                if (this.othersBubbles === 'payoff') {
                    let otherDecisionsForOpponent = otherDecisions.slice();
                    otherDecisionsForOpponent.splice(i, 1, this.myDecision);
                    /*
                    if(this.get('updateLandscape')) {
                        for(let x = 0; x < 598; x++) {
                            const val = (1 - this.get("constantD")) * payoffFunction(otherDecisions[i], otherDecisionsForOpponent) + this.get("constantD") * this.get("othersPixelValues")[i][x];
                            this.othersPixelValues[i][x] = val;
                        }
                    }*/
                    //0.97 is necessary here due to the slider length not quite matching up with the length of the axis
                    const otherSliderPosition = Math.round((otherDecisions[i]/(2 * this.get('constantA') + 1) * 598) * 0.97);
                    //payoff = payoffFunction(otherDecisions[i], otherDecisionsForOpponent);
                    //payoff = (1 - this.get("constantD")) * payoffFunction(otherDecisions[i], otherDecisionsForOpponent) + this.get("constantD") * this.get("pixelValues")[otherSliderPosition];
                    payoff = this.get("pixelValues")[otherSliderPosition];
                }
                ctx.beginPath();
                const x = (otherDecisions[i] - this.xMin) * this.xScale;
                const y = (this.yMax - payoff) * this.yScale;
                ctx.arc(x, y, radius, 0, 2 * Math.PI);

                ctx.lineWidth = 2;
                ctx.strokeStyle = OTHER_COLORS[i];
                ctx.stroke();
            }

            ctx.restore();
        },
        _drawMyDecision() {
            const ctx = this.ctx;

            ctx.save();

            ctx.save();
            this._transformContext();
            ctx.beginPath();
            ctx.moveTo(this.myDecision, 0);
            ctx.lineTo(this.myDecision, this.yMax);
            ctx.restore();
            ctx.strokeStyle = MY_COLOR;
            ctx.lineWidth = 2;
            ctx.stroke();

            const payoffFunction = this.get('payoffFunction');
            const otherDecisions = this.get('otherDecisions');

            const radius = 8;
            //0.97 is necessary here due to the slider length not quite matching up with the length of the axis
            const mySliderPosition = Math.round((this.myDecision/(2 * this.get('constantA') + 1) * 598) * 0.97);
            //const myPayoff = (1 - this.get("constantD")) * payoffFunction(this.myDecision, otherDecisions) + this.get("constantD") * this.get("pixelValues")[mySliderPosition];
            const myPayoff = this.get("pixelValues")[mySliderPosition];
            const x = (this.myDecision - this.xMin) * this.xScale;
            const y = (this.yMax - myPayoff) * this.yScale;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        },
        _drawXAxis() {
            const ctx = this.ctx;
            ctx.save();

            ctx.save();
            ctx.beginPath();
            this._transformContext();
            ctx.moveTo(0, 0);
            ctx.lineTo((this.get('constantA') * 2 + 1), 0);
            ctx.restore();
            ctx.stroke()

            const tickInterval = (this.get('constantA') * 2 + 1)/10;
            const tickWidth = 10;
            const tickStartY = this.yMax * this.yScale;
            const tickEndY = tickStartY + tickWidth;

            ctx.beginPath();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            let curTick = 0;
            while (curTick <= this.xMax) {
                let x = (curTick - this.xMin) * this.xScale;
                ctx.moveTo(x, tickStartY);
                ctx.lineTo(x, tickEndY);
                ctx.fillText(curTick.toFixed(1), x, tickEndY + 3)
                curTick += tickInterval;
            }
            ctx.stroke();

            ctx.restore();
        },
        _drawYAxis() {
            const ctx = this.ctx;
            ctx.save();

            ctx.save();
            this._transformContext();
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, this.yMax);
            ctx.restore();
            ctx.stroke();

            const tickInterval = this._getYTickInterval();
            const tickWidth = 10;
            const tickStartX = -this.xMin * this.xScale;
            const tickEndX = tickStartX - tickWidth;

            ctx.beginPath();
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            let curTick = 0;
            while (curTick < this.yMax) {
                let y = (this.yMax - curTick) * this.yScale;
                ctx.moveTo(tickStartX, y);
                ctx.lineTo(tickEndX, y);
                ctx.fillText(curTick, tickEndX - 3, y + 2);
                curTick += tickInterval;
            }
            ctx.stroke();

            ctx.restore();
        },
        _getYTickInterval() {
            const maxNumTicks = 12;

            if (this.yMax <= maxNumTicks) {
                return 1;
            }
            if (this.yMax / 5 <= maxNumTicks) {
                return 5;
            }

            let interval = 10;
            while (this.yMax / interval > maxNumTicks) {
                interval += 10;
            }
            return interval;
        }
    });
</script>
</dom-module>
