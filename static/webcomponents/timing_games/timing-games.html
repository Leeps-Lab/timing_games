<!-- webview for timing games
significant code taken from bimatrix

  todo: add titles for different webcomponents
        add an outline on the payoff graph
        setup export
        numeric payoff display for current and previous period
        add grid lines to bubbles and payoff graphs
        add payoff splitting for ties
        add config option to turn off payoff landscape

        current payoff, avg payoff, current strategy, ave strategy
-->

<link
    rel="import"
    href="/static/bower_components/polymer/polymer.html" />
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-channel/redwood-channel.html">
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-decision/redwood-decision.html">
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-period/redwood-period.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/polymer-bubbles.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/payoff-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/strategy-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/bubbles-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/colors.js">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/range.css">


<dom-module id="timing-games">

<template>
    <div>
        <polymer-bubbles
            max-payoff='[[ maxPayoff ]]'
            other-decisions='[[ otherDecisions ]]'
            my-decision='{{ myDecision }}'
            payoff-function='[[ _payoffFunction ]]'
            lambda='[[ lambda ]]'
            constant-h='[[ constantH ]]'
            duration='[[ periodLength ]]'
            enable-payoff-landscape='[[ enablePayoffLandscape ]]'
            others-bubbles='[[ othersBubbles ]]'
            update-rate='[[ updateRate ]]'
            num-players='[[ playersPerGroup ]]'
            x-min='[[ xMin ]]'
            x-max='[[ xMax ]]'
            y-min='[[ yMin ]]'
            y-max='[[ yMax ]]'
            display-lower='[[ displayLower ]]'
            display-upper='[[ displayUpper ]]'
            >
        </polymer-bubbles>
    </div>

    <otree-constants id="constants"></otree-constants>

    <redwood-period
        running="{{ _isPeriodRunning }}"
        on-period-start="_onPeriodStart"
        on-period-end="_onPeriodEnd">
    </redwood-period>

    <redwood-decision
        initial-decision="[[ initialDecision ]]"
        my-decision="{{ myDecision }}"
        group-decisions="{{ groupDecisions }}"
        max-per-second="10">
    </redwood-decision>
</template>

<script>
  Polymer({
      is: 'timing-games',
      properties: {
          initialDecision: {
              type: Number,
          },
          myDecision: {
              type: Number,
          },
          groupDecisions: {
              type: Object,
          },
          otherDecisions: {
              type: Array,
              computed: "_getOtherDecisions(groupDecisions)",
          },
          enablePayoffLandscape: {
              type: Boolean,
              value: false,
          },
          othersBubbles: {
              type: String,
          },
          updateRate: {
              type: Number,
          },
          playersPerGroup: {
              type: Number,
          },
          xMin: {
              type: Number,
          },
          xMax: {
              type: Number,
          },
          yMin: {
              type: Number,
          },
          yMax: {
              type: Number,
          },
          displayLower: {
              type: Number,
          },
          displayUpper: {
              type: Number,
          },
          lambda: {
              type: Number,
          },
          gamma: {
              type: Number,
          },
          rho: {
              type: Number,
          },
          constantH: {
              type: Number,
          },
          maxPayoff: {
              type: Number,
          },
          periodLength: Number,

          // set by redwood-period
          _isPeriodRunning: {
              type: Boolean
          },
          _subperiodProgress: {
              type: Number,
              value: 0,
          },
          _payoffFunction: {
              type: Object,
              value: function() {
                  return () => {};
              },
          },
      },
      ready() {
          this.$$('polymer-bubbles').roundStart();
          this.myDecision = this.initialDecision;

          const lambda = this.lambda;
          const gamma = this.gamma;
          const rho = this.rho;
          this._payoffFunction = function(myDecision, otherDecisions) {
            var pos = 1;
            var tie = 0;
            var numPlayers = otherDecisions.length + 1;
            for(var i = 0; i < otherDecisions.length; i++) {
                if(otherDecisions[i] < myDecision) {
                    pos++;
                }
                if(otherDecisions[i] == myDecision) {
                    tie += 1;
                }
            }

            if(tie > 0) {
                //max 1 + (2 * lambda * (1 + 2 * lambda)/2) - ((1 + 2 * lambda/2)^2)
                var ux = 1 + (2 * lambda * myDecision) - (myDecision * myDecision);
                var vy = 0;
                for(var i = 0; i <= tie; i++) {
                    //max (1 - ((numPlayers - 0.5)/numPlayers)/gamma) * (1 + ((numPlayers - 0.5)/numPlayers)/rho)
                    vy += ((1 - ((pos - 0.5 + i)/numPlayers)/gamma) * (1 + ((pos - 0.5 + i)/numPlayers)/rho));
                }
                vy = vy/(tie + 1);
                return ux * vy;
            }
            else {
                var ux = 1 + (2 * lambda * myDecision) - (myDecision * myDecision);
                var vy = (1 - ((pos - 0.5)/numPlayers)/gamma) * (1 + ((pos - 0.5)/numPlayers)/rho);
                return ux * vy;
            }

            /*
            if(tie >= 1) {
                return ((lambda * myDecision * (1 - gamma * myDecision)) * (rho * (pos + tie)/(tie * numPlayers) * (1 - constantD * (pos + tie)/(tie * numPlayers))) + 10);
            }
            else {
                return ((lambda * myDecision * (1 - gamma * myDecision)) * (rho * pos/numPlayers * (1 - constantD * pos/numPlayers)) + 10);
            } */

            /*
            if(tie > 1) {
                if(pos == 1 && lambda > 0) {
                    return (myDecision * lambda)/(tie) + 10;
                }
                if(gamma > 0 && (pos + tie - 1) == (numPlayers)) {
                    return ((1- myDecision) * gamma)/(tie) + 10;
                }
            }
            if(pos == 1) {
                return myDecision * lambda + 10;
            }
            else if(pos == (numPlayers)) {
                return (1 - myDecision) * gamma + 10;
            }
            else {
                return 10;
            } */
          }
      },

      getPayoff(myDecision, otherDecisions) {

      },

      _getOtherDecisions(groupDecisions) {
          var dec = [];
          for (var pcode in groupDecisions) {
              if(this.$.constants.participantCode != pcode) {
                  dec.push(groupDecisions[pcode]);
              }
          }

          return dec;
      },
    })
</script>

</dom-module>
