<!-- webview for timing games
significant code taken from bimatrix
  todo: add titles for different webcomponents
        add an outline on the payoff graph
        setup export
        numeric payoff display for current and previous period
        add grid lines to bubbles and payoff graphs
        add payoff splitting for ties
        add config option to turn off payoff landscape
        current payoff, avg payoff, current strategy, ave strategy
-->

<link
    rel="import"
    href="/static/bower_components/polymer/polymer.html" />
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-channel/redwood-channel.html">
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-decision/redwood-decision.html">
<link
    rel="import"
    href="/static/otree-redwood/webcomponents/redwood-period/redwood-period.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/polymer-bubbles.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/payoff-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/strategy-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/bubbles-graph.html">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/colors.js">
<link
    rel="import"
    href="/static/webcomponents/timing_games/polymer-bubbles/range.css">


<dom-module id="timing-games">

<template>
    <style>
        .wrapper {
            width: 1000px;
            position: absolute;
            left: 50%;
            top: 0;
            margin-left: -500px;
        }

        .wrapper polymer-bubbles {
            display: block;
            margin: 0 auto;
        }
    </style>
    <div>
        <polymer-bubbles
            other-decisions='[[ otherDecisions ]]'
            my-decision='{{ myDecision }}'
            payoff-function='[[ _payoffFunction ]]'
            sampled-decisions='[[ sampledDecisions ]]'
            lambda='[[ lambda ]]'
            constant-h='[[ constantH ]]'
            purification='[[ purification ]]'
            duration='[[ periodLength ]]'
            enable-payoff-landscape='[[ enablePayoffLandscape ]]'
            others-bubbles='[[ othersBubbles ]]'
            smoothing='[[ smoothing ]]'
            update-rate='[[ updateRate ]]'
            num-players='[[ playersPerGroup ]]'
            x-min='[[ xMin ]]'
            x-max='[[ xMax ]]'
            y-min='[[ yMin ]]'
            y-max='[[ yMax ]]'
            bandwidth='[[ bandwidth ]]'
            pixel-values='{{ pixelValues }}'
            sample-size='[[ samepleSize ]]'
            >
        </polymer-bubbles>
    </div>

    <otree-constants id="constants"></otree-constants>

    <redwood-period
        running="{{ _isPeriodRunning }}"
        on-period-start="_onPeriodStart"
        on-period-end="_onPeriodEnd">
    </redwood-period>

    <redwood-decision-bot
        id="bot"
        my-decision="{{ myDecision }}"
        other-decision="[[ otherDecision ]]">
    </redwood-decision-bot>

    <redwood-decision
        initial-decision="[[ initialDecision ]]"
        my-decision="{{ myDecision }}"
        group-decisions="{{ groupDecisions }}"
        max-per-second="10">
    </redwood-decision>
</template>

<script>
  Polymer({
      is: 'timing-games',
      properties: {
          initialDecision: {
              type: Number,
          },
          myDecision: {
              type: Number,
          },
          groupDecisions: {
              type: Object,
          },
          otherDecisions: {
              type: Array,
              computed: "_getOtherDecisions(groupDecisions)",
          },
          sampledDecisions: {
              type: Array,
          },
          enablePayoffLandscape: {
              type: Boolean,
              value: false,
          },
          othersBubbles: {
              type: String,
          },
          smoothing: {
              type: String,
          },
          updateRate: {
              type: Number,
          },
          pixelValues: {
              type: Array,
              value: [],
              notify: true,
          },
          playersPerGroup: {
              type: Number,
          },
          xMin: {
              type: Number,
          },
          xMax: {
              type: Number,
          },
          yMin: {
              type: Number,
          },
          yMax: {
              type: Number,
          },
          lambda: {
              type: Number,
          },
          gamma: {
              type: Number,
          },
          rho: {
              type: Number,
          },
          constantH: {
              type: Number,
          },
          bandwidth: {
              type: Number,
          },
          maxPayoff: {
              type: Number,
          },
          bots: {
              type: Boolean,
              value: false,
          },
          sampleSize: {
              type: Number,
          },
          myCurrPayoff: {
              type: Number,
          },
          constantE: {
              type: Number,
          },
          purification: {
              type: Number,
          },
          periodLength: Number,
          // set by redwood-period
          _isPeriodRunning: {
              type: Boolean
          },
          _subperiodProgress: {
              type: Number,
              value: 0,
          },
          _payoffFunction: {
              type: Object,
              value: function() {
                  return () => {};
              },
          },
      },
      ready() {
          //this.$$('polymer-bubbles').roundStart();
          //this.myDecision = this.initialDecision;
          const lambda = this.lambda;
          const gamma = this.gamma;
          const rho = this.rho;
          this._payoffFunction = function(myDecision, otherDecisions) {
            var pos = 1;
            var tie = 0;
            var numPlayers = otherDecisions.length + 1;
            for(var i = 0; i < otherDecisions.length; i++) {
                if(otherDecisions[i] < myDecision) {
                    pos++;
                }
                if(otherDecisions[i] == myDecision) {
                    tie += 1;
                }
            }
            if(tie > 0) {
                //max 1 + (2 * lambda * (1 + 2 * lambda)/2) - ((1 + 2 * lambda/2)^2)
                var ux = 1 + (2 * lambda * myDecision) - (myDecision * myDecision);
                var vy = 0;
                for(var i = 0; i <= tie; i++) {
                    //max (1 - ((numPlayers - 0.5)/numPlayers)/gamma) * (1 + ((numPlayers - 0.5)/numPlayers)/rho)
                    vy += ((1 - ((pos - 0.5 + i)/numPlayers)/gamma) * (1 + ((pos - 0.5 + i)/numPlayers)/rho));
                }
                vy = vy/(tie + 1);
                this.myCurrPayoff = ux * vy;
                return ux * vy;
            }
            else {
                var ux = 1 + (2 * lambda * myDecision) - (myDecision * myDecision);
                var vy = (1 - ((pos - 0.5)/numPlayers)/gamma) * (1 + ((pos - 0.5)/numPlayers)/rho);
                this.myCurrPayoff = ux * vy;
                return ux * vy;
            }
          }
      },
      _getOtherDecisions(groupDecisions) {
          let codes = Object.keys(groupDecisions);
          codes.sort();
          let sampling = false;
          let sampled = []
          let puriVal = 0;

          var dec = [];
          for (let pcode of codes) {
              if(this.$.constants.participantCode != pcode) {
                  dec.push(groupDecisions[pcode]);
              }
              if(this.$.constants.participantCode == pcode) {
                  sampling = true;
                  this.purification = this.constantE * (puriVal/codes.length);
                  continue;
              }
              if(sampling && sampled.length < this.sampleSize) {
                  sampled.push(groupDecisions[pcode]);
              }
              puriVal++;
          }
          if(sampled.length < this.sampleSize) {
              for(let pcode of codes) {
                  sampled.push(groupDecisions[pcode]);
                  if(sampled.length == this.sampleSize) {
                      break;
                  }
              }
          }
          if(this.constantE < 0) {
              this.purification = 1;
          }
          this.sampledDecisions = sampled;
          return dec;
      },
      _onPeriodStart() {
          this.$$('polymer-bubbles').roundStart();
          let startTime = Date.now();
          this.myDecision = this.initialDecision;
          if(this.bots) {
              console.log("bots are turned on");
              function tick() {
                  let best = -99999;
                  let choice = 0;
                  let wait = 0;
                  // for(let dec = this.xMin; dec < this.xMax; dec += ((this.xMax - this.xMin)/100)) {
                  //     var pos = 1;
                  //     var tie = 0;
                  //     var numPlayers = this.otherDecisions.length + 1;
                  //     for(var i = 0; i < this.otherDecisions.length; i++) {
                  //         if(this.otherDecisions[i] < dec) {
                  //             pos++;
                  //         }
                  //         if(this.otherDecisions[i] == dec) {
                  //             tie += 1;
                  //         }
                  //     }
                  //     if(tie > 0) {
                  //         //max 1 + (2 * lambda * (1 + 2 * lambda)/2) - ((1 + 2 * lambda/2)^2)
                  //         var ux = 1 + (2 * this.lambda * dec) - (dec * dec);
                  //         var vy = 0;
                  //         for(var i = 0; i <= tie; i++) {
                  //             //max (1 - ((numPlayers - 0.5)/numPlayers)/gamma) * (1 + ((numPlayers - 0.5)/numPlayers)/rho)
                  //             vy += ((1 - ((pos - 0.5 + i)/numPlayers)/this.gamma) * (1 + ((pos - 0.5 + i)/numPlayers)/this.rho));
                  //         }
                  //         vy = vy/(tie + 1);
                  //         if((ux * vy) >= best) {
                  //             best = ux * vy;
                  //             choice = dec;
                  //         }
                  //     }
                  //     else {
                  //         var ux = 1 + (2 * this.lambda * dec) - (dec * dec);
                  //         var vy = (1 - ((pos - 0.5)/numPlayers)/this.gamma) * (1 + ((pos - 0.5)/numPlayers)/this.rho);
                  //         if((ux * vy) >= best) {
                  //             best = ux * vy;
                  //             choice = dec;
                  //         }
                  //     }
                  // }
                  for(let i = 0; i < this.pixelValues.length; i++) {
                      if(this.pixelValues[i] > best) {
                          best = this.pixelValues[i];
                          choice = i;
                      }
                  }
                  choice = (choice/this.pixelValues.length) * (this.xMax - this.xMin) + this.xMin;
                  wait = 2000/(best - this.myCurrPayoff) + Math.random() * 100;
                  this.myDecision = choice + Math.random()/20 - 0.05;
                  // const timeDiff = Date.now() - startTime;
                  setTimeout(tick.bind(this), 700 + wait);
              }
              tick.call(this);
          }
      },
    })
</script>

</dom-module>
